from flask import Flask, send_file, render_template, request, jsonify
import tempfile
import os
from openai import OpenAI
from dotenv import load_dotenv
load_dotenv()

from music21 import stream, note, midi, converter, environment, chord, meter, key, tempo, metadata, expressions
import pretty_midi
from gtts import gTTS

# MuseScore 경로 설정
us = environment.UserSettings()
us['musicxmlPath'] = 'C:/Program Files/MuseScore 4/bin/MuseScore4.exe'
us['musescoreDirectPNGPath'] = 'C:/Program Files/MuseScore 4/bin/MuseScore4.exe'

app = Flask(__name__)

@app.route("/")
def index():
    return render_template("index.html")

client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# 파일명 처리 함수 (ub300위시 제거)
def sanitize_filename(title: str) -> str:
    return title.replace(" ", "_")

@app.route("/generate-lyrics", methods=["POST"])
def generate_lyrics():
    try:
        topic = request.json.get("topic", "사랑에 관한 노래")
        prompt = f"'{topic}'이라는 주제로 한국어 노래 가사를 쓰여주세요. 4줄 이상."
        response = client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": prompt}]
        )
        lyrics = response.choices[0].message.content.strip()
        return jsonify({"lyrics": lyrics})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route("/generate-melody", methods=["POST"])
def generate_melody():
    try:
        melody = stream.Stream()
        melody.append(note.Note('C4', quarterLength=1.0))
        melody.append(note.Note('D4', quarterLength=1.0))
        melody.append(note.Note('E4', quarterLength=1.0))
        melody.append(note.Rest(quarterLength=1.0))
        melody.append(note.Note('G4', quarterLength=2.0))

        midi_path = tempfile.mktemp(suffix=".mid")
        mf = midi.translate.streamToMidiFile(melody)
        mf.open(midi_path, 'wb')
        mf.write()
        mf.close()

        pm = pretty_midi.PrettyMIDI(midi_path)
        wav_path = midi_path.replace(".mid", ".wav")
        pm.write(wav_path)

        return send_file(wav_path, mimetype="audio/wav")
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route("/generate-song", methods=["POST"])
def generate_song():
    try:
        lyrics = request.json.get("lyrics", "사랑이 떠날 그날 밤")

        emotion_prompt = f"다음 가사에서 느껴지는 감정을 하나의 단어로 요약해주세요: {lyrics}"
        emotion_response = client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": emotion_prompt}]
        )
        emotion = emotion_response.choices[0].message.content.strip().lower()

        title_prompt = f"다음 가사에 어울리는 한국어 노래 제목을 6자 이내로 정해주세요. 따옴표 없이 단어만 주세요: {lyrics}"
        title_response = client.chat.completions.create(
            model="gpt-4",
            messages=[{"role": "user", "content": title_prompt}]
        )
        title = title_response.choices[0].message.content.strip()
        safe_title = sanitize_filename(title)

        emotion_chord_map = {
            "슬평": ["Am", "F", "C", "G"],
            "기빨": ["C", "G", "Am", "F"],
            "분노": ["Em", "C", "D", "Bm"],
            "사랑": ["F", "G", "Em", "Am"],
            "기본": ["C", "Am", "F", "G"]
        }
        chords = emotion_chord_map.get(emotion, emotion_chord_map["기본"])

        score = stream.Score()
        part = stream.Part()
        score.insert(0, metadata.Metadata())
        score.metadata.title = title
        score.append(tempo.MetronomeMark(number=90))
        part.append(meter.TimeSignature("4/4"))
        part.append(key.Key(chords[0]))

        title_expression = expressions.TextExpression(title)
        title_expression.style.fontSize = 18
        part.insert(0, title_expression)

        for chord_symbol in chords * 2:
            if chord_symbol == "C":
                c = chord.Chord(["C4", "E4", "G4"])
            elif chord_symbol == "Am":
                c = chord.Chord(["A3", "C4", "E4"])
            elif chord_symbol == "F":
                c = chord.Chord(["F3", "A3", "C4"])
            elif chord_symbol == "G":
                c = chord.Chord(["G3", "B3", "D4"])
            elif chord_symbol == "Em":
                c = chord.Chord(["E3", "G3", "B3"])
            elif chord_symbol == "D":
                c = chord.Chord(["D3", "F#3", "A3"])
            elif chord_symbol == "Bm":
                c = chord.Chord(["B2", "D3", "F#3"])
            else:
                c = chord.Chord(["C4", "E4", "G4"])
            c.quarterLength = 4
            part.append(c)

        for chord_symbol in chords * 2:
            for p in chord.Chord(["C4", "E4", "G4"]).pitches[:2]:
                n = note.Note(p)
                n.quarterLength = 1
                part.append(n)

        score.append(part)

        base_path = os.path.join(tempfile.gettempdir(), safe_title)
        midi_path = f"{base_path}.mid"
        wav_path = f"{base_path}.wav"
        pdf_path = f"{base_path}.pdf"

        score.write("midi", fp=midi_path)
        try:
            score.write("musicxml.pdf", fp=pdf_path)
            print("✅ PDF 저장 성공:", pdf_path)
        except Exception as e:
            print("❌ PDF 저장 실패:", str(e))

        pm = pretty_midi.PrettyMIDI(midi_path)
        pm.write(wav_path)

        print("✅ PDF 저장 경로:", pdf_path)

        return jsonify({
            "title": title,
            "safe_title": safe_title,
            "wav_url": f"/download/wav?title={safe_title}",
            "pdf_url": f"/score?title={safe_title}"
        })

    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route("/score", methods=["GET"])
def score():
    try:
        safe_title = request.args.get("title", "제목없는_악보")
        pdf_path = os.path.join(tempfile.gettempdir(), f"{safe_title}.pdf")

        if not os.path.exists(pdf_path):
            return jsonify({"error": "악보 PDF 파일이 존재하지 않습니다."}), 404

        return send_file(pdf_path, mimetype="application/pdf", as_attachment=True, download_name=f"{safe_title}.pdf")
    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == "__main__":
    app.run(debug=True)

